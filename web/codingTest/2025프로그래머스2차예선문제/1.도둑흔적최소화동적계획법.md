문제 설명

A도둑과 B도둑이 팀을 이루어 모든 물건을 훔치려고 합니다. 단, 각 도둑이 물건을 훔칠 때 남기는 흔적이 누적되면 경찰에 붙잡히기 때문에, 두 도둑 중 누구도 경찰에 붙잡히지 않도록 흔적을 최소화해야 합니다.
물건을 훔칠 때 조건은 아래와 같습니다.
물건 i를 훔칠 때,
A도둑이 훔치면 info[i][0]개의 A에 대한 흔적을 남깁니다.
B도둑이 훔치면 info[i][1]개의 B에 대한 흔적을 남깁니다.
각 물건에 대해 A도둑과 B도둑이 남기는 흔적의 개수는 1 이상 3 이하입니다.
경찰에 붙잡히는 조건은 아래와 같습니다.
A도둑은 자신이 남긴 흔적의 누적 개수가 n개 이상이면 경찰에 붙잡힙니다.
B도둑은 자신이 남긴 흔적의 누적 개수가 m개 이상이면 경찰에 붙잡힙니다.
각 물건을 훔칠 때 생기는 흔적에 대한 정보를 담은 2차원 정수 배열 info, A도둑이 경찰에 붙잡히는 최소 흔적 개수를 나타내는 정수 n, B도둑이 경찰에 붙잡히는 최소 흔적 개수를 나타내는 정수 m이 매개변수로 주어집니다. 두 도둑 모두 경찰에 붙잡히지 않도록 모든 물건을 훔쳤을 때, A도둑이 남긴 흔적의 누적 개수의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 만약 어떠한 방법으로도 두 도둑 모두 경찰에 붙잡히지 않게 할 수 없다면 -1을 return해 주세요.
제한사항
1 ≤ info의 길이 ≤ 40
info[i]는 물건 i를 훔칠 때 생기는 흔적의 개수를 나타내며, [A에 대한 흔적 개수, B에 대한 흔적 개수]의 형태입니다.
1 ≤ 흔적 개수 ≤ 3
1 ≤ n ≤ 120
1 ≤ m ≤ 120
테스트 케이스 구성 안내
아래는 테스트 케이스 구성을 나타냅니다. 각 그룹 내의 테스트 케이스를 모두 통과하면 해당 그룹에 할당된 점수를 획득할 수 있습니다.
그룹 총점 테스트 케이스 그룹 설명
#1 15% info[i][1] = 1
#2 40% info의 길이 ≤ 20
#3 45% 추가 제한 사항 없음
입출력 예
info n m result
[[1, 2], [2, 3], [2, 1]] 4 4 2
[[1, 2], [2, 3], [2, 1]] 1 7 0
[[3, 3], [3, 3]] 7 1 6
[[3, 3], [3, 3]] 6 1 -1
입출력 예 설명
입출력 예 #1
첫 번째와 세 번째 물건을 B도둑이 훔치고 두 번째 물건을 A도둑이 훔치면, A도둑에 대한 흔적은 총 2개이고 B도둑에 대한 흔적은 총 3개입니다. 목표를 달성하면서 A도둑에 대한 흔적 개수를 2보다 더 낮게 만들 수 없습니다.
따라서 2를 return 해야 합니다.
입출력 예 #2
B도둑이 모든 물건을 훔쳐도 B의 흔적이 7개 이상 쌓이지 않습니다.
따라서 A도둑의 흔적은 최소 0이 되며, 0을 return 해야 합니다.
입출력 예 #3
B도둑이 한 번이라도 물건을 훔치면 B의 흔적이 최소 1개 이상 남습니다. 따라서 모든 물건을 A도둑이 훔쳐야 하며, 이 경우에도 A의 흔적은 7개 미만입니다.
따라서, A도둑이 모든 물건을 훔칠 때의 흔적 개수 6을 return 해야 합니다.
입출력 예 #4
어떤 방법으로도 두 도둑 모두 경찰에 붙잡히지 않고 모든 물건을 훔칠 수 없습니다.
따라서 -1을 return 해야 합니다.

---

## 소스 코드 설명

### 알고리즘 접근 방법

이 문제는 **동적 계획법(Dynamic Programming)**을 사용하여 해결합니다. 각 물건을 순차적으로 처리하면서, B도둑의 누적 흔적에 따른 A도둑의 최소 누적 흔적을 계산합니다.

### 핵심 아이디어

- **DP 상태 정의**: `dp[j]` = B도둑의 누적 흔적이 `j`일 때, A도둑의 누적 흔적의 최솟값
- B도둑의 흔적이 `m` 이상이면 경찰에 붙잡히므로, `m` 이상의 상태는 고려할 필요가 없습니다.
- 따라서 DP 배열의 크기는 `m`으로 충분합니다.

### 코드 동작 과정

#### 1. 초기화 (5-8줄)

```javascript
let dp = new Array(m).fill(Infinity);
dp[0] = 0;
```

- `dp` 배열을 `Infinity`로 초기화합니다.
- `dp[0] = 0`: 아무 물건도 훔치지 않은 상태에서 B의 흔적은 0, A의 흔적도 0입니다.

#### 2. 각 물건 처리 (10-30줄)

각 물건에 대해 두 가지 선택지를 고려합니다:

**a) A도둑이 물건을 훔치는 경우 (17-21줄)**

```javascript
if (dp[bTrace] + costA < n) {
  nextDp[bTrace] = Math.min(nextDp[bTrace], dp[bTrace] + costA);
}
```

- B의 흔적(`bTrace`)은 변하지 않고, A의 흔적만 `costA`만큼 증가합니다.
- A의 흔적이 `n` 미만이어야 경찰에 붙잡히지 않습니다.
- 같은 B 흔적 상태에서 A의 흔적 최솟값을 갱신합니다.

**b) B도둑이 물건을 훔치는 경우 (23-27줄)**

```javascript
if (bTrace + costB < m) {
  nextDp[bTrace + costB] = Math.min(nextDp[bTrace + costB], dp[bTrace]);
}
```

- B의 흔적이 `costB`만큼 증가하고, A의 흔적은 변하지 않습니다.
- B의 흔적이 `m` 미만이어야 경찰에 붙잡히지 않습니다.
- 새로운 B 흔적 상태에서 A의 흔적 최솟값을 갱신합니다.

#### 3. 결과 계산 (32-35줄)

```javascript
const answer = Math.min(...dp);
return answer === Infinity ? -1 : answer;
```

- 모든 물건을 처리한 후, `dp` 배열에 저장된 A의 흔적 중 최솟값을 찾습니다.
- 모든 값이 `Infinity`라면 해결 방법이 없는 것이므로 `-1`을 반환합니다.

### 시간 복잡도

- **시간 복잡도**: O(물건 개수 × m)
  - 각 물건에 대해 `m`개의 상태를 확인하므로
- **공간 복잡도**: O(m)
  - DP 배열의 크기가 `m`이므로

### 예시 동작 흐름

예를 들어 `info = [[1, 2], [2, 3]], n = 4, m = 4`인 경우:

1. **초기 상태**: `dp = [0, ∞, ∞, ∞]` (B의 흔적이 0일 때 A의 흔적은 0)

2. **첫 번째 물건 [1, 2] 처리**:

   - A가 훔치는 경우: `dp[0] + 1 = 1 < 4` → `nextDp[0] = 1`
   - B가 훔치는 경우: `0 + 2 = 2 < 4` → `nextDp[2] = 0`
   - 결과: `dp = [1, ∞, 0, ∞]`

3. **두 번째 물건 [2, 3] 처리**:

   - `dp[0] = 1`에서:
     - A가 훔치면: `1 + 2 = 3 < 4` → `nextDp[0] = 3`
     - B가 훔치면: `0 + 3 = 3 < 4` → `nextDp[3] = 1`
   - `dp[2] = 0`에서:
     - A가 훔치면: `0 + 2 = 2 < 4` → `nextDp[2] = 2`
     - B가 훔치면: `2 + 3 = 5 ≥ 4` → 불가능
   - 결과: `dp = [3, ∞, 2, 1]`

4. **최종 결과**: `Math.min(3, ∞, 2, 1) = 1`

이 알고리즘은 모든 가능한 물건 분배 방법을 효율적으로 탐색하여 최적해를 찾습니다.
