<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Event Loop</title>
    <link rel="stylesheet" href="../../common/style/reset.css" />
    <link rel="stylesheet" href="../../common/style/utils.css" />
    <script src="../../common/js/import.js"></script>
  </head>
  <body>
      <main>
        <section>
          <h2>이벤트 루프란 무엇인가?</h2>
          <p class="pre-line"><strong>JavaScript가 싱글 스레드 환경에서 비동기 작업을 처리하기 위한 실행 메커니즘입니다.</strong>
            JavaScript 엔진은 한 번에 하나의 작업만 처리하지만, 이벤트 루프를 통해 논블로킹(Non-Blocking) 방식의 비동기
            처리가 가능합니다. 핵심 포인트는 다음 세 가지 입니다.<br />
          </p>

          <ul>
            <li>JavaScript는 싱글 스레드 언어입니다. ( 한 번에 하나의 작업만 처리할 수 있습니다. )</li>
            <li>비동기 작업은 즉시 실행되지 않고 큐(Queue)에 추가됩니다.</li>
            <li>
              이벤트 루프가 콜 스택(Call Stack)이 비어있을 때, 큐(Queue)에서 대기 중인 비동기 작업을 꺼내서 처리합니다.
            </li>
          </ul>

          <h2>이벤트 루프 주요 구성 요소</h2>

          <ol>
            <li>
              Call Stack ( 콜 스택 ) <br />
              <ul>
                <li>JavaScript 코드가 실행될 때 함수 호출이 쌓이는 곳</li>
                <li>Last In First Out ( LIFO ) 구조 방식으로 작동하며, 싱글 스레드</li>
              </ul>
            </li>
            <li>
              Web API / Node.js API ( 웹 API / Node.js API )<br />
              <ul>
                <li>브라우저 혹은 Node.js 환경에서 제공하는 API</li>
                <li>비동기 작업을 처리하는 역할</li>
                <li>setTimeout, fetch, DOM 이벤트 핸들러 등</li>
              </ul>
            </li>
            <li>
              Callback Queue ( 콜백 큐 ) <br />
              <ul>
                <li>비동기 작업이 완료된 후 콜백 함수가 임시로 대기하는 곳</li>
                <li>Microtask와 Macrotask가 대기하는 곳</li>
              </ul>
            </li>
            <li>
              Event Loop ( 이벤트 루프 ) <br />
              <ul>
                <li>
                  Call Stack이 비어 있는지를 지속적으로 확인하고, Call Stack이 비어있으면 Callback Queue에서 대기 중인
                  비동기 작업을 꺼내서 Call Stack에 추가하여 실행합니다.
                </li>
              </ul>
            </li>
          </ol>

          <h2>마이크로태스크/매크로태스크</h2>

          <ol>
            <li>
              Microtask ( 마이크로태스크 )<br />
              <ul>
                <li>
                  Promise의 then, catch, finally, async/await(내부적으로 Promise를 사용하기 때문) queueMicrotask()
                </li>
                <li>
                  이벤트 루프가 한 번 돌 때(하나의 매크로태스크 실행이 끝날 때마다), Callback Queue(매크로태스크 큐)보다
                  먼저 처리되어야 합니다.
                </li>
              </ul>
            </li>
            <li>
              Macrotask ( 매크로태스크 )<br />
              <ul>
                <li>setTimeout, setInterval, DOM Event, I/O 작업 등</li>
                <li>다음 매크로태스크가 실행되기 전에 모든 마이크로태스크가 처리되어야 합니다.</li>
              </ul>
            </li>
          </ol>

          <h2>이벤트 루프 동작 순서</h2>

          <ol>
            <li>Call Stack에 있는 동기 코드 실행</li>
            <li>Call Stack이 비었으면,</li>
            <li>Microtask Queue의 모든 작업 실행 (Promise 처리)</li>
            <li>Microtask Queue가 비었으면,</li>
            <li>Macrotask Queue에서 하나의 작업 실행(setTimeout, DOM 이벤트 등)</li>
            <li>이 과정 (1~5)을 반복</li>
          </ol>

          <h2>실무 관전에서 중요한 이유</h2>

          <ol>
            <li>
              렌더링 지연 문제<br />
              <ul>
                <li>Microtask가 과도하면 브라우저 렌더링이 밀림</li>
                <li>무한 Promise 체인은 화면 멈춤 원인</li>
              </ul>
            </li>
            <li>
              상태 업데이트 타이밍<br />
              <ul>
                <li>React에서 setState 이후 DOM 반영 시점 이해</li>
                <li>비동기 로직에서 순서 보장을 위해 중요</li>
              </ul>
            </li>
            <li>
              성능 최적화<br />
              <ul>
                <li>무거운 로직을 동기로 두면 UX 저하 원인</li>
                <li>requestAnimationFrame, 비동기 분리 설계 필요</li>
              </ul>
            </li>
            <li>
              디버깅 능력<br />
              <ul>
                <li>"왜 이 코드가 먼저 실행됐지?"에 대한 명확한 설명 가능</li>
                <li>면접에서 실무 이해도를 판단하는 기준</li>
              </ul>
            </li>
          </ol>
        </div>
      </section>
    </main>

    <!-- <script>
      alert("동기 코드 1");
      setTimeout(() => {
        alert("매크로태스크 2");
      }, 0);
      Promise.resolve().then(() => {
        alert("마이크로태스크 3");
      });
      Promise.resolve().then(() => {
        alert("마이크로태스크 4.1");
        setTimeout(() => {
          alert("매크로태스크 4.2");
        }, 0);
        Promise.resolve().then(() => {
          alert("마이크로태스크 4.3");
        });
      });
      alert("동기 코드 5");
    </script> -->
  </body>
</html>
